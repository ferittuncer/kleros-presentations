title: EIP 792
class: animation-fade
layout: true

.bottom-bar[{{title}}]

---

class: impact

# {{title}}

## The standard for Arbitra(tion/ble) smart contracts.

???
Welcome everyone, today we will go over Kleros' arbitration ethereum improvement proposal, which aims to standardize the way the demand side of dispute resolution (the arbitrable side) interacts with the supply side (the arbitration side).

The aim of the proposal is to provide a minimal interface by which any two conforming contracts can interact with each other to execute dispute resolution, regardless of implementation details. This way, dapps and their smart contracts can plug and play any contract that implements the standard. This will create a competitive market for arbitrators, which in turn will lead to better services, at lower prices, for consumers, all without additional development costs for any of the parties involved.

By the end of the presentation, you should have a clear understanding of how to develop smart contracts that adhere to the standard. OK, so let's get started.

---

# A Primer on Blockchains

## They:

- Are distributed data stores that can be used to store any sort of data .alt.thin.small[(e.g. Bitcoin stores balances for a bunch of addresses.)].

--

- Can be edited as long as certain rules are followed .alt.thin.small[(e.g. No double spending, no spending of others' funds, etc.)].

--

- Guarantee provable data integrity, commonly through different consensus protocols based on `cryptography + economics = cryptoeconomics`.

---

# Smart? Contracts

## They:

- Are turing complete, stateful programs that get sent in a special deployment `TX` and become immutable.

--

- Have their own address to which you can send `TX`s with some input data and value and have some logic executed on-chain.

--

- Guarantee provable data and state transition integrity through the chain they live on, in our case, Ethereum.

???
The simplest way of picturing them in Ethereum is as special wallets that expose an `instance` of a `class` to which you can send special transactions to. These special transactions execute your specified methods of the `instance`, with your specified inputs, and can modify its state. You can also read this state at any time. These `instance`s have access to all sorts of `TX` and chain metadata and can also interact with other `instance`s of other `class`es and even transfer ETH.

In distributed applications, databases become contract state, and APIs become contract methods.
