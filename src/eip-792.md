title: EIP 792
subtitle: The standard for Arbitra(tion/ble) smart contracts.
class: animation-fade
layout: true

.bottom-bar[{{title}} - {{subtitle}}]

---

class: impact

# {{title}}

## {{subtitle}}

???
Welcome everyone, today we will go over Kleros' arbitration ethereum improvement proposal, which aims to standardize the way the demand side of dispute resolution (the arbitrable side) interacts with the supply side (the arbitration side).

The aim of the proposal is to provide a minimal interface by which any two conforming contracts can interact with each other to execute dispute resolution, regardless of implementation details. This way, dapps and their smart contracts can plug and play any contract that implements the standard. This will create a competitive market for arbitrators, which in turn will lead to better services, at lower prices, for consumers, all without additional development costs for any of the parties involved.

By the end of the presentation, you should have a clear understanding of how to develop smart contracts that adhere to the standard. OK, so let's get started.

---

# A Primer on Blockchains

## They:

--

- Are distributed data stores that can be used to store any sort of data .alt.thin.small[(e.g. Bitcoin stores balances for a bunch of addresses.)].

--

- Can be edited as long as certain rules are followed .alt.thin.small[(e.g. No double spending, no spending of others' funds, etc.)].

--

- Guarantee provable data integrity, commonly through different consensus protocols based on `cryptography + economics = cryptoeconomics`.

---

# Smart? Contracts

## They:

--

- Are turing complete, stateful programs that get sent in a special deployment `TX` and become immutable.

--

- Have their own address to which you can send `TX`s with some input data and value and have some logic executed on-chain.

--

- Guarantee provable data and state transition integrity through the chain they live on, in our case, Ethereum.

???
The simplest way of picturing them in Ethereum is as special wallets that expose an `instance` of a `class` to which you can send special transactions to. These special transactions execute your specified methods of the `instance`, with your specified inputs, and can modify its state. You can also read this state at any time. These `instance`s have access to all sorts of `TX` and chain metadata and can also interact with other `instance`s of other `class`es and even transfer ETH.

In distributed applications, databases become contract state, and APIs become contract methods.

---

# A Note on Smart Contract Design

--

.col-6[

### Traditional Back Ends:

- Do most of the heavy lifting for the front end, because computation is cheap and faster than on the client.

.responsive[![Traditional Back End](https://apexminecrafthosting.com/wp-content/uploads/2015/10/apex_server8.gif)]

]

--

.col-6[

### Smart Contracts Back Ends:

- Leave most of the heavy lifting for the front end, because computation is expensive and slower than on the client.

.responsive[![Smart Contract Back End](https://www.conceptdraw.com/How-To-Guide/picture/fully-connected-network-topology/Network-Topology-Fully-Connected.png)]

]

???
This is an inherent property of consensus based systems that involve lots of parties.

Improvements will always be made, but it will also always be cheaper to execute code on the front end.

Abstractions can be made to make front end developers' lifes easier. `kleros-api` does just that for EIP 792 contracts.

---

# EIP 792 Arbitrator: Interface

.small[

```sol
contract Arbitrator {
    function createDispute(
        uint _choices, bytes _extraData
    ) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {};

    function arbitrationCost(bytes _extraData) public view returns(uint fee);

    function appeal(
        uint _disputeID, bytes _extraData
    ) public requireAppealFee(_disputeID,_extraData) payable {
        emit AppealDecision(_disputeID, Arbitrable(msg.sender));
    }

    function appealCost(uint _disputeID, bytes _extraData) public view returns(uint fee);

    function appealPeriod(uint _disputeID) public view returns(uint start, uint end) {}

    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status);

    function currentRuling(uint _disputeID) public view returns(uint ruling);
}
```

]

???
These are all the methods that an arbitrable contract should need to execute a dispute resolution flow. Let's go over each method one by one.

Note that we've removed the Doxygen comments for simplicity.

We have:

- A way of creating a dispute.
- A way of getting the cost of creating a dispute.
- A way of appealing a ruling.
- A way of getting the cost of appealing a ruling.
- (Optional) A way to see the time window you have for appealing a ruling (Useful for multi-party fee payments.).
- A way of getting a dispute's status.
- A way of getting a dispute's current ruling (You might want to appeal it before it's final.).

---

# EIP 792 Arbitrator: Types and Events

.small[

```sol
contract Arbitrator {
    enum DisputeStatus { Waiting, Appealable, Solved }

    event DisputeCreation(uint indexed _disputeID, Arbitrable indexed _arbitrable);

    event AppealPossible(uint indexed _disputeID, Arbitrable indexed _arbitrable);

    event AppealDecision(uint indexed _disputeID, Arbitrable indexed _arbitrable);
}
```

]

???
For types we just have an enum that tells you if the dispute is waiting for a ruling, in an appeal period, or already resolved.

Events are like immutable logs that can be efficiently indexed and queried by clients.

We have:

- One for when a dispute is created.
- One for when a dispute's ruling becomes appealable.
- One for when a dispute's ruling is appealed.

---

# EIP 792 Arbitrable: Interface and Events

.small[

```sol
contract Arbitrable {
    event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);

    function rule(uint _disputeID, uint _ruling) public onlyArbitrator;
}
```

]

### Evidence Standard:

[Link](link)

### Composed Arbitrable Contracts:

[Link](link)

???
This is all that an arbitrator contract should need to execute a dispute resolution flow.

We have a way for the arbitrator to give a final ruling and an event to notify clients when that happens.

As you can see, this interface is much simpler than the arbitrator one. But, that doesn't mean that arbitrable contracts are always easier to implement. There is a lot of complex logic involved with evidence submission, multi-party and crowdinsured fee payments, and then there is what the contract does after a ruling is given. That's why we have developed a few things on top of EIP 792 to make it easier for third parties to create arbitrable contracts.

We have an evidence event standard for submission and verification of off-chain data to serve as context, like the ruling question and possible decisions, and evidence for a dispute. We also have a set of composable arbitrable contracts that each implement a piece of the puzzle and can be used through inheritance or a proxy model. We will actually give an example of that later today.

---

## EIP 792 Arbitrator: Simple Example

### Centralized Arbitrator: Set Up

.small[

```sol
contract CentralizedArbitrator is Arbitrator {
    struct Dispute {
        Arbitrable arbitrated;
        uint choices;
        uint fee;
        uint ruling;
        DisputeStatus status;
    }

    address public owner = msg.sender;
    uint arbitrationPrice;
    uint constant NON_PAYABLE_VALUE = (2 ** 256 - 2) / 2;
    Dispute[] public disputes;

    modifier onlyOwner {require(msg.sender == owner, "Can only be called by the owner."); _;}

    constructor(uint _arbitrationPrice) public {arbitrationPrice = _arbitrationPrice;}
}
```

]

???
OK, so now let's go over how one might implement an actual working arbitrator. We'll go over the code of a simple centralized arbitrator where one party can execute rulings unanimously and without possibility of appeals, and then we'll briefly go over more complex architectures using our very own Kleros Liquid as an example.

First, we inherit from the arbitrator interface. Then we define a struct type for our disputes and all the storage variables we'll need. This is state that persists and is shared between different `TX` executions.

We have:

- The address of the owner to authorize certain actions like giving rulings.
- The arbitration price so we can change it like a setting. Note that we did not make it public, which automatically creates a getter, because `arbitrationCost` will already act as a getter.
- A non payable value, more than the total supply of ETH, to block appeals without having to change the standard interface.
- A list of disputes.

We then define a modifier, this is basically like a very simple implementation of function decorators where the underscore gets replaced with the function's actual body.

Finally, we define the constructor which only takes and sets the arbitration price.

---

## EIP 792 Arbitrator: Simple Example

### Centralized Arbitrator: Setters and Getters

.small[

```sol
contract CentralizedArbitrator is Arbitrator {
    function setArbitrationPrice(uint _arbitrationPrice) public onlyOwner {
        arbitrationPrice = _arbitrationPrice;
    }
    function arbitrationCost(bytes _extraData) public view returns(uint fee) {
        return arbitrationPrice;
    }
    function appealCost(uint _disputeID, bytes _extraData) public view returns(uint fee) {
        return NON_PAYABLE_VALUE;
    }
    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status) {
        return disputes[_disputeID].status;
    }
    function currentRuling(uint _disputeID) public view returns(uint ruling) {
        return disputes[_disputeID].ruling;
    }
}
```

]

???
We have:

- A setter for the arbitration price. Note that it has the `onlyOwner` modifier so that not anyone can change the price.
- The standard getter for arbitration cost.
- The standard getter for appeal cost, always returning a non payable value because this contract does not support appeals.
- The standard getter for a dispute's status.
- The standard getter for a dispute's current ruling.

The modifier `view` tells the compiler that those functions don't modify state, only read from it, which means they can be executed on the Ethereum virtual machine without a transaction being sent, which also means no gas fees for the caller. You can get pretty smart with views and implement complex query functions that support traditional API patterns like pagination, sorting, and filtering.

---

## EIP 792 Arbitrator: Simple Example

### Centralized Arbitrator: Creating and Ruling Disputes

.extra-small[

```sol
contract CentralizedArbitrator is Arbitrator {
    function createDispute(uint _choices, bytes _extraData) public payable returns(uint disputeID)  {
        super.createDispute(_choices, _extraData);
        disputeID = disputes.push(DisputeStruct({
            arbitrated: Arbitrable(msg.sender),
            choices: _choices,
            fee: msg.value,
            ruling: 0,
            status: DisputeStatus.Waiting
        })) - 1;
        emit DisputeCreation(disputeID, Arbitrable(msg.sender));
    }

    function giveRuling(uint _disputeID, uint _ruling) public onlyOwner {
        DisputeStruct dispute = disputes[_disputeID];
        require(_ruling <= dispute.choices, "Invalid ruling.");
        require(dispute.status != DisputeStatus.Solved, "The dispute has already been ruled.")

        dispute.ruling = _ruling;
        dispute.status = DisputeStatus.Solved;
        msg.sender.send(dispute.fee);
        dispute.arbitrated.rule(_disputeID, _ruling);
    }
}
```

]

???
Now we need a way to create and solve disputes.

For creating disputes, first, we call the parent contract's implementation to enforce the arbitration cost. Then, we insert a new dispute into the list and save it's ID, which is just its index. Note the payable modifier which means that the function can receive ETH.

We set:

- `arbitrated`: To the sender.
- `choices`: To the passed in parameter.
- `fee`: To the amount of ETH, in Wei, sent with the `TX`.
- `ruling`: To 0, the initial value.
- `status`: To waiting.

Then we emit the standard event and we are done.

The function for giving a ruling is also very simple. First, we define a reference to the specified dispute for easy reference. We check that the ruling is within the range of choices and that the dispute has not already been ruled. If any of these conditions fail, we revert and the `TX` has no effect. We then save the dispute's ruling, set the dispute's status to solved, send the fee to the caller, and call rule on the arbitrable contract. Note that the caller is always the owner because the function has the `onlyOwner` modifier.

And there you have it, a fully working, EIP 792 standard compliant arbitrator.
